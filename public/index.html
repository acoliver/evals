<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vybes Scoreboard</title>
  <link rel="stylesheet" href="vybestack.css" />
</head>
<body>
  <main class="container">
    <header class="top-bar">
      <div>
        <h1>Vybes Scoreboard</h1>
        <p class="cta-lead">Daily LLxprt evaluation scores in glorious greenscreen.</p>
      </div>
    </header>

    <section>
      <h2>Daily Overview</h2>
      <div class="table-wrapper">
        <table id="daily-table">
          <thead>
            <tr>
              <th class="sortable" data-field="profileLabel">Profile</th>
              <th class="sortable sorted desc" data-field="totalVybes">Total Vybes</th>
              <th class="sortable" data-field="runs">Runs</th>
              <th class="sortable" data-field="avgVybes">Avg Vybes</th>
              <th class="sortable" data-field="avgSuccess">Avg Success</th>
              <th class="sortable" data-field="avgPenalty">Avg Penalty</th>
              <th>Best Run</th>
              <th>Worst Run</th>
            </tr>
          </thead>
          <tbody id="daily-summary"></tbody>
        </table>
      </div>
    </section>

    <section>
      <h2>Run Log</h2>
      <div class="table-wrapper">
        <table id="run-table">
          <thead>
            <tr>
              <th class="sortable" data-field="finishedAtValue">Finished</th>
              <th class="sortable" data-field="profileLabel">Profile</th>
              <th class="sortable" data-field="evalName">Scenario</th>
              <th class="sortable" data-field="finalScore">Vybes</th>
              <th class="sortable" data-field="successPercentage">Success</th>
              <th class="sortable" data-field="timePenaltyMultiplier">Penalty</th>
              <th class="sortable" data-field="actualTimeMinutes">Minutes</th>
              <th class="sortable" data-field="subtasks">Subtasks</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody id="run-log"></tbody>
        </table>
      </div>
    </section>

    <footer>
      Updated <span id="updated-at">never</span>. Serve this directory (e.g. <code>npx serve public</code>) for live data.
    </footer>
  </main>

  <script type="module">
    const PROFILE_LABELS = {
      'llxprt-synthetic-glm4.6-temp1': 'Synthetic GLM 4.6',
      'cerebrasqwen3-qwen3-coder-temp1': 'Qwen3 Coder',
      'codex-exec-gpt5-default': 'Codex GPT-5'
    };

    const EVAL_LABELS = {
      'base64-fix': 'Base64 Toolkit Fix',
      'form-capture': 'Friendly Form Capture',
      'pagination': 'Pagination Service Repair',
      'react-evaluation': 'Reactive Programming Primitives',
      'regex-challenge': 'Regex Challenge Toolkit',
      'report-builder': 'Report Builder Repair'
    };

    const formatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2 });
    const percentFormatter = new Intl.NumberFormat(undefined, { style: 'percent', maximumFractionDigits: 1 });
    const dateFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });

    const dailyBody = document.getElementById('daily-summary');
    const runsBody = document.getElementById('run-log');
    const dailyTable = document.getElementById('daily-table');
    const runTable = document.getElementById('run-table');
    const updatedAtEl = document.getElementById('updated-at');

    let currentDailyRows = [];
    let currentRunRows = [];
    let dailySort = { field: 'totalVybes', desc: true };
    let runSort = { field: 'finishedAtValue', desc: true };

    async function safeFetch(path) {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Failed to load ${path}: ${response.status}`);
      }
      return response.json();
    }

    function createDailyRows(daily) {
      const rows = [];
      daily.forEach((entry) => {
        const dayLabel = entry.date === 'unknown' ? 'Unknown Date' : entry.date;
        const profiles = Object.entries(entry.profiles);
        profiles.forEach(([configId, stats]) => {
          rows.push({
            date: dayLabel,
            configId,
            totalVybes: stats.totalVybes,
            runs: stats.runs,
            avgVybes: stats.avgVybes,
            avgSuccess: stats.avgSuccess,
            avgPenalty: stats.avgPenalty,
            bestRun: stats.bestRun,
            worstRun: stats.worstRun,
            profileLabel: PROFILE_LABELS[configId] ?? configId
          });
        });
      });
      return rows;
    }

    function updateDailyTable() {
      dailyBody.innerHTML = currentDailyRows.map((row) => {
        const best = row.bestRun
          ? `${EVAL_LABELS[row.bestRun.eval] ?? row.bestRun.eval} (${formatter.format(row.bestRun.score)})`
          : '–';
        const worst =
          row.worstRun && row.worstRun.runId !== row.bestRun?.runId
            ? `${EVAL_LABELS[row.worstRun.eval] ?? row.worstRun.eval} (${formatter.format(row.worstRun.score)})`
            : '–';
        return `<tr>
          <td>${row.profileLabel}<br/><small>${row.date}</small></td>
          <td data-field="totalVybes">${formatter.format(row.totalVybes)}</td>
          <td data-field="runs">${row.runs}</td>
          <td data-field="avgVybes">${formatter.format(row.avgVybes)}</td>
          <td data-field="avgSuccess">${percentFormatter.format(row.avgSuccess)}</td>
          <td data-field="avgPenalty">${formatter.format(row.avgPenalty)}</td>
          <td>${best}</td>
          <td>${worst}</td>
        </tr>`;
      }).join('');
    }

    function updateRunTable() {
      runsBody.innerHTML = currentRunRows.map((run) => {
        const scenario = EVAL_LABELS[run.evalName] ?? run.evalName;
        const finishedLabel = run.finishedAtValue ? dateFormatter.format(new Date(run.finishedAtValue)) : 'unknown';
        const error = run.error ? `<span class="badge-fail">${run.error}</span>` : '–';
        return `<tr>
          <td>${finishedLabel}</td>
          <td>${run.profileLabel}</td>
          <td data-field="evalName">${scenario}</td>
          <td data-field="finalScore">${formatter.format(run.finalScore)}</td>
          <td data-field="successPercentage">${percentFormatter.format(run.successPercentage)}</td>
          <td data-field="timePenaltyMultiplier">${formatter.format(run.timePenaltyMultiplier)}</td>
          <td data-field="actualTimeMinutes">${formatter.format(run.actualTimeMinutes)}</td>
          <td data-field="subtasks">${run.subtasksPassed}/${run.subtasksTotal}</td>
          <td>${error}</td>
        </tr>`;
      }).join('');
    }

    function sortRows(rows, sortState, field, numeric = true) {
      const desc = sortState.field === field ? !sortState.desc : true;
      sortState.field = field;
      sortState.desc = desc;
      rows.sort((a, b) => {
        const valueA = a[field];
        const valueB = b[field];
        if (numeric) {
          return desc ? (valueB ?? 0) - (valueA ?? 0) : (valueA ?? 0) - (valueB ?? 0);
        }
        const strA = String(valueA ?? '').toLowerCase();
        const strB = String(valueB ?? '').toLowerCase();
        if (strA < strB) return desc ? 1 : -1;
        if (strA > strB) return desc ? -1 : 1;
        return 0;
      });
      return desc;
    }

    function markSortHeader(table, field, desc) {
      const headers = Array.from(table.querySelectorAll('th.sortable'));
      headers.forEach((header) => {
        header.classList.remove('sorted', 'asc', 'desc');
        if (header.dataset.field === field) {
          header.classList.add('sorted', desc ? 'desc' : 'asc');
        }
      });
    }

    function bindSortHandlers(table, rows, sortState, updateFn, fieldConfig) {
      const headers = Array.from(table.querySelectorAll('th.sortable'));
      headers.forEach((header) => {
        header.addEventListener('click', () => {
          const field = header.dataset.field;
          const config = fieldConfig[field] ?? {};
          const numeric = config.numeric ?? true;
          const desc = sortRows(rows, sortState, field, numeric);
          updateFn();
          markSortHeader(table, field, desc);
        });
      });
      markSortHeader(table, sortState.field, sortState.desc);
    }

    async function bootstrap() {
      try {
        const [daily, runs] = await Promise.all([
          safeFetch('vybes-daily.json'),
          safeFetch('vybes-runs.json')
        ]);

        currentDailyRows = createDailyRows(daily);
        sortRows(currentDailyRows, dailySort, dailySort.field, dailySort.field !== 'profile');
        updateDailyTable();

        currentRunRows = runs.map((run) => {
          const subtasksPassed = run.vybes.breakdown?.subtasksPassed ?? 0;
          const subtasksTotal = run.vybes.breakdown?.subtasksTotal ?? 0;
          return {
            ...run,
            profileLabel: PROFILE_LABELS[run.configId] ?? run.configId,
            finalScore: run.vybes.finalScore ?? 0,
            successPercentage: run.vybes.successPercentage ?? 0,
            timePenaltyMultiplier: run.vybes.timePenaltyMultiplier ?? 0,
            actualTimeMinutes: run.vybes.actualTimeMinutes ?? 0,
            subtasksPassed,
            subtasksTotal,
            subtasks: subtasksTotal ? subtasksPassed / subtasksTotal : 0,
            finishedAtValue: run.finishedAt ? Date.parse(run.finishedAt) : 0,
            error: run.vybes.error ?? null
          };
        });
        sortRows(currentRunRows, runSort, runSort.field, runSort.field !== 'evalName' && runSort.field !== 'configId');
        updateRunTable();

        bindSortHandlers(dailyTable, currentDailyRows, dailySort, updateDailyTable, {
          profileLabel: { numeric: false },
          totalVybes: { numeric: true },
          runs: { numeric: true },
          avgVybes: { numeric: true },
          avgSuccess: { numeric: true },
          avgPenalty: { numeric: true }
        });

        bindSortHandlers(runTable, currentRunRows, runSort, updateRunTable, {
          finishedAtValue: { numeric: true },
          profileLabel: { numeric: false },
          evalName: { numeric: false },
          finalScore: { numeric: true },
          successPercentage: { numeric: true },
          timePenaltyMultiplier: { numeric: true },
          actualTimeMinutes: { numeric: true },
          subtasks: { numeric: false }
        });

        const lastRun = runs[runs.length - 1];
        if (lastRun?.finishedAt) {
          updatedAtEl.textContent = dateFormatter.format(new Date(lastRun.finishedAt));
        } else {
          updatedAtEl.textContent = 'unknown';
        }
      } catch (error) {
        dailyTarget.innerHTML = `<p class="badge-fail">${error.message}. Serve the site via HTTP to enable fetch().</p>`;
        runsTarget.innerHTML = '';
        console.error(error);
      }
    }

    bootstrap();
  </script>
</body>
</html>
